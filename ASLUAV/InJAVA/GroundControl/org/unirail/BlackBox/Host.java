
/**
 * Apache License
 * Version 2.0, January 2004
 * http://www.apache.org/licenses/
 * <p>
 * TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
 * <p>
 * 1. Definitions.
 * <p>
 * "License" shall mean the terms and conditions for use, reproduction,
 * and distribution as defined by Sections 1 through 9 of this document.
 * <p>
 * "Licensor" shall mean the copyright owner or entity authorized by
 * the copyright owner that is granting the License.
 * <p>
 * "Legal Entity" shall mean the union of the acting entity and all
 * other entities that control, are controlled by, or are under common
 * control with that entity. For the purposes of this definition,
 * "control" means (i) the power, direct or indirect, to cause the
 * direction or management of such entity, whether by contract or
 * otherwise, or (ii) ownership of fifty percent (50%) or more of the
 * outstanding shares, or (iii) beneficial ownership of such entity.
 * <p>
 * "You" (or "Your") shall mean an individual or Legal Entity
 * exercising permissions granted by this License.
 * <p>
 * "Source" form shall mean the preferred form for making modifications,
 * including but not limited to software source code, documentation
 * source, and configuration files.
 * <p>
 * "Object" form shall mean any form resulting from mechanical
 * transformation or translation of a Source form, including but
 * not limited to compiled object code, generated documentation,
 * and conversions to other media types.
 * <p>
 * "Work" shall mean the work of authorship, whether in Source or
 * Object form, made available under the License, as indicated by a
 * copyright notice that is included in or attached to the work
 * (an example is provided in the Appendix below).
 * <p>
 * "Derivative Works" shall mean any work, whether in Source or Object
 * form, that is based on (or derived from) the Work and for which the
 * editorial revisions, annotations, elaborations, or other modifications
 * represent, as a whole, an original work of authorship. For the purposes
 * of this License, Derivative Works shall not include works that remain
 * separable from, or merely link (or bind by name) to the interfaces of,
 * the Work and Derivative Works thereof.
 * <p>
 * "Contribution" shall mean any work of authorship, including
 * the original version of the Work and any modifications or additions
 * to that Work or Derivative Works thereof, that is intentionally
 * submitted to Licensor for inclusion in the Work by the copyright owner
 * or by an individual or Legal Entity authorized to submit on behalf of
 * the copyright owner. For the purposes of this definition, "submitted"
 * means any form of electronic, verbal, or written communication sent
 * to the Licensor or its representatives, including but not limited to
 * communication on electronic mailing lists, source code control systems,
 * and issue tracking systems that are managed by, or on behalf of, the
 * Licensor for the purpose of discussing and improving the Work, but
 * excluding communication that is conspicuously marked or otherwise
 * designated in writing by the copyright owner as "Not a Contribution."
 * <p>
 * "Contributor" shall mean Licensor and any individual or Legal Entity
 * on behalf of whom a Contribution has been received by Licensor and
 * subsequently incorporated within the Work.
 * <p>
 * 2. Grant of Copyright License. Subject to the terms and conditions of
 * this License, each Contributor hereby grants to You a perpetual,
 * worldwide, non-exclusive, no-charge, royalty-free, irrevocable
 * copyright license to reproduce, prepare Derivative Works of,
 * publicly display, publicly perform, sublicense, and distribute the
 * Work and such Derivative Works in Source or Object form.
 * <p>
 * 3. Grant of Patent License. Subject to the terms and conditions of
 * this License, each Contributor hereby grants to You a perpetual,
 * worldwide, non-exclusive, no-charge, royalty-free, irrevocable
 * (except as stated in this section) patent license to make, have made,
 * use, offer to sell, sell, import, and otherwise transfer the Work,
 * where such license applies only to those patent claims licensable
 * by such Contributor that are necessarily infringed by their
 * Contribution(s) alone or by combination of their Contribution(s)
 * with the Work to which such Contribution(s) was submitted. If You
 * institute patent litigation against any entity (including a
 * cross-claim or counterclaim in a lawsuit) alleging that the Work
 * or a Contribution incorporated within the Work constitutes direct
 * or contributory patent infringement, then any patent licenses
 * granted to You under this License for that Work shall terminate
 * as of the date such litigation is filed.
 * <p>
 * 4. Redistribution. You may reproduce and distribute copies of the
 * Work or Derivative Works thereof in any medium, with or without
 * modifications, and in Source or Object form, provided that You
 * meet the following conditions:
 * <p>
 * (a) You must give any other recipients of the Work or
 * Derivative Works a copy of this License; and
 * <p>
 * (b) You must cause any modified files to carry prominent notices
 * stating that You changed the files; and
 * <p>
 * (c) You must retain, in the Source form of any Derivative Works
 * that You distribute, all copyright, patent, trademark, and
 * attribution notices from the Source form of the Work,
 * excluding those notices that do not pertain to any part of
 * the Derivative Works; and
 * <p>
 * (d) If the Work includes a "NOTICE" text file as part of its
 * distribution, then any Derivative Works that You distribute must
 * include a readable copy of the attribution notices contained
 * within such NOTICE file, excluding those notices that do not
 * pertain to any part of the Derivative Works, in at least one
 * of the following places: within a NOTICE text file distributed
 * as part of the Derivative Works; within the Source form or
 * documentation, if provided along with the Derivative Works; or,
 * within a display generated by the Derivative Works, if and
 * wherever such third-party notices normally appear. The contents
 * of the NOTICE file are for informational purposes only and
 * do not modify the License. You may add Your own attribution
 * notices within Derivative Works that You distribute, alongside
 * or as an addendum to the NOTICE text from the Work, provided
 * that such additional attribution notices cannot be construed
 * as modifying the License.
 * <p>
 * You may add Your own copyright statement to Your modifications and
 * may provide additional or different license terms and conditions
 * for use, reproduction, or distribution of Your modifications, or
 * for any such Derivative Works as a whole, provided Your use,
 * reproduction, and distribution of the Work otherwise complies with
 * the conditions stated in this License.
 * <p>
 * 5. Submission of Contributions. Unless You explicitly state otherwise,
 * any Contribution intentionally submitted for inclusion in the Work
 * by You to the Licensor shall be under the terms and conditions of
 * this License, without any additional terms or conditions.
 * Notwithstanding the above, nothing herein shall supersede or modify
 * the terms of any separate license agreement you may have executed
 * with Licensor regarding such Contributions.
 * <p>
 * 6. Trademarks. This License does not grant permission to use the trade
 * names, trademarks, service marks, or product names of the Licensor,
 * except as required for reasonable and customary use in describing the
 * origin of the Work and reproducing the content of the NOTICE file.
 * <p>
 * 7. Disclaimer of Warranty. Unless required by applicable law or
 * agreed to in writing, Licensor provides the Work (and each
 * Contributor provides its Contributions) on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
 * implied, including, without limitation, any warranties or conditions
 * of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
 * PARTICULAR PURPOSE. You are solely responsible for determining the
 * appropriateness of using or redistributing the Work and assume any
 * risks associated with Your exercise of permissions under this License.
 * <p>
 * 8. Limitation of Liability. In no event and under no legal theory,
 * whether in tort (including negligence), contract, or otherwise,
 * unless required by applicable law (such as deliberate and grossly
 * negligent acts) or agreed to in writing, shall any Contributor be
 * liable to You for damages, including any direct, indirect, special,
 * incidental, or consequential damages of any character arising as a
 * result of this License or out of the use or inability to use the
 * Work (including but not limited to damages for loss of goodwill,
 * work stoppage, computer failure or malfunction, or any and all
 * other commercial damages or losses), even if such Contributor
 * has been advised of the possibility of such damages.
 * <p>
 * 9. Accepting Warranty or Additional Liability. While redistributing
 * the Work or Derivative Works thereof, You may choose to offer,
 * and charge a fee for, acceptance of support, warranty, indemnity,
 * or other liability obligations and/or rights consistent with this
 * License. However, in accepting such obligations, You may act only
 * on Your own behalf and on Your sole responsibility, not on behalf
 * of any other Contributor, and only if You agree to indemnify,
 * defend, and hold each Contributor harmless for any liability
 * incurred by, or claims asserted against, such Contributor by reason
 * of your accepting any such warranty or additional liability.
 * <p>
 * END OF TERMS AND CONDITIONS
 * <p>
 * Copyright 2017 Chikirev Sirguy, Unirail Group
 * <p>
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * http://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * in short
 * Permissions
 * Commercial use
 * Distribution
 * Modification
 * Private use
 * Conditions
 * License and copyright notice
 * Limitations
 * Liability
 * Warranty
 **/

/**
 in short
 Permissions
 Commercial use
 Distribution
 Modification
 Private use
 Conditions
 License and copyright notice
 Limitations
 Liability
 Warranty
 **/
package org.unirail.BlackBox;


import java.io.IOException;
import java.util.ArrayList;

import static org.unirail.BlackBox.BitUtils.*;

public abstract class Host {

	public static abstract class Pack {
		public final Meta   meta;
		public       byte[] data;

		public Pack(Meta meta, int opt_bytes) {
			this.meta = meta;
			data = opt_bytes < 0 ? null : new byte[meta.packMinBytes + opt_bytes];
		}


		public static class Meta {
			public final int id;

			final int _2;
			final int _4;
			final int _8;

			final char    _dbbox;
			final int     _Jbbox;
			final Field[] fields;

			final int packMinBytes;

			public Meta(int id, int _2, int _4, int _8, int packMinBytes, int _Jbbox) { this(id, _2, _4, _8, packMinBytes, _Jbbox, 0); }

			public Meta(int id, int _2, int _4, int _8, int packMinBytes, int _Jbbox, int _dbbox, Field... fields) {
				this.id = id;
				this._2 = _2;
				this._4 = _4;
				this._8 = _8;
				this._dbbox = (char) _dbbox;
				this._Jbbox = _Jbbox;
				this.fields = fields != null && fields.length == 0 ? null : fields;
				this.packMinBytes = packMinBytes;
			}


			public static class Field {
				final char    type;
				final boolean varint;

				final        int   length;
				final        byte  size;
				public final int[] dims;


				final int _Ubbox;


				final char _pbbox;
				final char _Sbbox;
				final char _hbbox;

				public Field(int type, boolean varint, int length, int size, int _Ubbox, int _pbbox, int _hbbox, int _Sbbox, int... dims) {
					this.type = (char) type;
					this.varint = varint;
					this.length = length;
					this.size = (byte) size;
					this._Ubbox = _Ubbox;
					this._pbbox = (char) _pbbox;
					this._Sbbox = (char) _Sbbox;
					this._hbbox = (char) _hbbox;
					this.dims = dims;
				}


				public static class Bounds {

					public Pack pack;

					public int field_bit;
					public int field_size = 0;
					Field field;
					int   _vbbox;


					int _Obbox = -1;

					int _ubbox = -1;
					int _Wbbox = -1;

					int _Hbbox;
					int _nbbox;
					int _Dbbox;

					public static class Inside extends Bounds {

						public int[] D = new int[10];

						public int BIT = -1;
						public int BYTE;

						public int items;

						int _ibbox;
						int field_item;
						int _Ibbox;
						int _lbbox;

						public boolean wasNULL = false;


						@Override public void setPack(Pack pack) {
							super.setPack(pack);
							BIT = _vbbox;
							BYTE = _Wbbox;
							items = 0;
							field_size = 0;
							_ibbox = -1;
							field_item = Integer.MAX_VALUE;
							_Ibbox = 0;
						}
					}

					public void setPack(Pack pack) {
						this.pack = pack;
						field_bit = -1;
						Meta meta = pack.meta;
						_ubbox = _Wbbox = meta.packMinBytes + (meta._dbbox == 0 ? 0 : (int) get_bits(pack.data, meta._Jbbox - meta._dbbox, meta._dbbox));
						_vbbox = _Obbox = (_ubbox) << 3;
						field_size = 0;
						_Dbbox = -1;
						_Hbbox = -1;
						_nbbox = -1;
					}
				}
			}
		}
	}

	public abstract static class Channel {
		private static class Flow extends Pack.Meta.Field.Bounds {

			long _fbbox;
			char crc;

			boolean next() {
				final Pack.Meta meta = pack.meta;
				final byte[]    data = pack.data;
				int             delta;
				if (field_bit == -1)
					switch (field_size)
					{
						case 0:
							if (0 < meta._2)
							{
								_ubbox += meta._2 * (field_size = 2);
								state = STATE.VARINT;
								return true;
							}
						case 2:
							if (0 < meta._4)
							{
								_ubbox += meta._4 * (field_size = 4);
								state = STATE.VARINT;
								return true;
							}
						case 4:
							if (0 < meta._8)
							{
								_ubbox += meta._8 * (field_size = 8);
								state = STATE.VARINT;
								return true;
							}
						case 8:
							if (_Wbbox < (_ubbox = meta.packMinBytes))
							{
								state = STATE.BYTES;
								field_size = 1;
								return true;
							}
							mode = Flow.MODE.NONE;
						default:
							if (meta.fields == null)
								return false;
							int fix = _Wbbox;
							setPack(pack);
							if (mode == MODE.NONE && fix < _ubbox)
							{
								_Wbbox = fix;
								state = STATE.BYTES;
								mode = MODE.OPTS_INFO;
								field_size = 1;
								return true;
							}
							mode = MODE.NONE;
							if ((delta = first_1(data, meta._Jbbox, _vbbox - meta._Jbbox, false)) == -1) return false;
							field_bit = meta._Jbbox - 1;
					}
				else
					if (field_bit - meta._Jbbox == meta.fields.length - 1 || (delta = first_1(data, field_bit + 1, _vbbox - (field_bit + 1), false)) == -1) return false;
				do
				{
					field_bit += delta + 1;
					Pack.Meta.Field fld = pack.meta.fields[field_bit - meta._Jbbox];
					field = fld;
					state = fld.varint ? STATE.VARINT : STATE.BYTES;
					_Obbox = _vbbox;
					_Wbbox = _ubbox;
					if (0 < fld.length) if (0 < fld.size) _ubbox += fld._Ubbox * fld.length * (field_size = fld.size);
					else _vbbox += fld._Ubbox * fld.length * fld.size;
					else setBounds(fld, this);
					if (_Wbbox == _ubbox)
						if ((delta = first_1(data, field_bit + 1, _vbbox - (field_bit + 1), false)) == -1) return false;
						else continue;
					break;
				}
				while (true);
				return true;
			}

			STATE state = STATE.STANDBY;

			enum STATE {
				STANDBY, PACK_ID, VARINT, VARINT_BR, BYTES, BYTES_BR;
			}

			MODE mode = MODE.NONE;

			enum MODE {
				OPTS_INFO, SET, NONE, CRC
			}
		}

		protected static byte pack_id_bytes = 1;

		public class InputStream extends java.io.InputStream {
			final Flow p2b = new Flow();


			@Override public int read() throws IOException {
				byte[] bytes = new byte[1];
				read(bytes, 0, 1);
				return bytes[0];
			}

			@Override public int read(byte[] dst, int BYTE, int bytes) throws IOException {
				final int fix = BYTE;
				for (; 0 < bytes--; BYTE++)
				{
					switch (p2b.state)
					{
						case STANDBY:
							if ((p2b.pack = process(null, PROCESS_CHANNEL_REQEST)) == null) return BYTE - fix;
							p2b.state = Flow.STATE.PACK_ID;
							p2b._fbbox = p2b.pack.meta.id;
							p2b.field_bit = 8 * (pack_id_bytes - 1);
						case PACK_ID:
							dst[BYTE] = (byte) (0xFF & p2b._fbbox >>> p2b.field_bit);
							if (-1 < (p2b.field_bit -= 8)) continue;
							p2b._fbbox = 0;
							p2b.field_bit = -1;
							p2b._vbbox = p2b._Obbox = p2b._ubbox = p2b._Wbbox = p2b.field_size = 0;
							p2b.mode = Flow.MODE.NONE;
							if (p2b.pack.meta.fields != null)
							{
								p2b.state = Flow.STATE.VARINT;
								final Pack.Meta meta = p2b.pack.meta;
								p2b.setPack(p2b.pack);
								_wbbox(p2b);
								p2b._fbbox = (p2b._Hbbox + 1) - meta.packMinBytes;
								p2b._vbbox = p2b._Obbox = p2b._ubbox = p2b._Wbbox = p2b.field_size = 0;
								continue;
							}
							break;
						case BYTES:
							dst[BYTE] = p2b.pack.data[p2b._Wbbox++];
							if (p2b._Wbbox < p2b._ubbox) continue;
							break;
						case VARINT:
							if ((p2b._fbbox & ~0x7FL) != 0)
							{
								dst[BYTE] = (byte) (p2b._fbbox & 0x7F | 0x80);
								p2b._fbbox >>>= 7;
								continue;
							}
							dst[BYTE] = (byte) p2b._fbbox;
							if ((p2b._Wbbox += p2b.field_size) < p2b._ubbox)
							{
								p2b._fbbox = get_bytes(p2b.pack.data, p2b._Wbbox, p2b.field_size);
								continue;
							}
					}
					if (p2b.next())
					{
						if (p2b.state == Flow.STATE.VARINT) p2b._fbbox = get_bytes(p2b.pack.data, p2b._Wbbox, p2b.field_size);
						continue;
					}
					p2b.state = Flow.STATE.STANDBY;
					p2b.mode = Flow.MODE.NONE;
					p2b.pack = null;
				}
				return BYTE - fix;
			}
		}

		public class OutputStream extends java.io.OutputStream {
			int bits = 0;

			final Flow b2p = new Flow();

			@Override public void write(int b) throws IOException {
				byte[] bytes = new byte[1];
				bytes[0] = (byte) (b & 0xFF);
				write(bytes, 0, 1);
			}

			@Override public void write(byte[] src, int BYTE, int bytes) throws IOException {
				time = ~0;
				if (time == 0)
				{
					time = ~0;
					b2p.state = Flow.STATE.STANDBY;
					if (b2p.pack != null) b2p.pack = null;
				}
				for (; 0 < bytes--; BYTE++)
				{
					switch (b2p.state)
					{
						case STANDBY:
							b2p._fbbox = 0;
							bits = 0;
							b2p.state = Flow.STATE.PACK_ID;
						case PACK_ID:
							b2p._fbbox = b2p._fbbox << 8 | src[BYTE] & 0xFF;
							if (++bits < pack_id_bytes) continue;
							b2p.mode = Flow.MODE.NONE;
							assert b2p.pack == null;
							if ((b2p.pack = process(null, (int) b2p._fbbox)) == null)
							{
								failure("Unrecognized package ID = " + b2p._fbbox);
								b2p.state = Flow.STATE.STANDBY;
								continue;
							}
							b2p._fbbox = 0;
							bits = 0;
							b2p.field_bit = -1;
							b2p._vbbox = b2p._Obbox = b2p._ubbox = b2p._Wbbox = b2p.field_size = 0;
							if (b2p.pack.meta.fields != null)
							{
								b2p.state = Flow.STATE.VARINT;
								b2p.mode = Flow.MODE.OPTS_INFO;
								continue;
							}
							break;
						case BYTES:
							b2p.pack.data[b2p._Wbbox++] = src[BYTE];
							if (b2p._Wbbox < b2p._ubbox) continue;
							break;
						case VARINT:
							b2p._fbbox |= (src[BYTE] & 0x7FL) << bits;
							bits += 7;
							if ((src[BYTE] & 0x80) != 0) continue;
							bits = 0;
							if (b2p.mode == Flow.MODE.OPTS_INFO)
							{
								b2p.pack.data = new byte[b2p.pack.meta.packMinBytes + (int) b2p._fbbox];
								b2p._fbbox = 0;
								b2p.mode = Flow.MODE.NONE;
								break;
							}
							set_bytes(b2p._fbbox, b2p.field_size, b2p.pack.data, b2p._Wbbox);
							b2p._fbbox = 0;
							if ((b2p._Wbbox += b2p.field_size) < b2p._ubbox) continue;
							break;
					}
					if (b2p.next()) continue;
					b2p.state = Flow.STATE.STANDBY;
					b2p.mode = Flow.MODE.NONE;
					process(b2p.pack, PROCESS_CHANNEL_REQEST);
					b2p.pack = null;
				}
			}
		}

		private static final char tab[] = {0, 4129, 8258, 12387, 16516, 20645, 24774, 28903, 33032, 37161, 41290, 45419, 49548, 53677, 57806, 61935};


		private static char crc16(byte data, char crc) {
			int UBYTE = data & 0xFF;
			crc = (char) (tab[(crc >> 12 ^ UBYTE >> 4) & 0x0F] ^ crc << 4);
			return (char) (tab[(crc >> 12 ^ UBYTE & 0x0F) & 0x0F] ^ crc << 4);
		}

		private static final byte BR = 0x55;

		public class AdvancedInputStream extends InputStream {
			@Override public int read(byte[] dst, int BYTE, int bytes) throws IOException {
				final int fix = BYTE;
				for (int t; 0 < bytes--; t = p2b.mode != Flow.MODE.CRC ? p2b.crc = crc16(dst[BYTE], p2b.crc) : 0, BYTE++)
				{
					switch (p2b.state)
					{
						case STANDBY:
							if ((p2b.pack = process(null, PROCESS_CHANNEL_REQEST)) == null) return BYTE - fix;
							p2b.state = Flow.STATE.PACK_ID;
							p2b._fbbox = p2b.pack.meta.id;
							p2b.field_bit = 8 * (pack_id_bytes - 1);
							p2b.crc = 0;
							dst[BYTE] = BR;
							continue;
						case PACK_ID:
							dst[BYTE] = (byte) (0xFF & p2b._fbbox >>> p2b.field_bit);
							if (-1 < (p2b.field_bit -= 8)) continue;
							p2b._fbbox = 0;
							p2b.field_bit = -1;
							p2b._vbbox = p2b._Obbox = p2b._ubbox = p2b._Wbbox = p2b.field_size = 0;
							p2b.mode = Flow.MODE.NONE;
							if (p2b.pack.meta.fields != null)
							{
								p2b.state = Flow.STATE.VARINT;
								final Pack.Meta meta = p2b.pack.meta;
								p2b.setPack(p2b.pack);
								_wbbox(p2b);
								p2b._fbbox = (p2b._Hbbox + 1) - meta.packMinBytes;
								p2b._vbbox = p2b._Obbox = p2b._ubbox = p2b._Wbbox = p2b.field_size = 0;
								continue;
							}
							break;
						case BYTES:
							if (p2b.mode == Flow.MODE.CRC)
							{
								switch (p2b.field_size)
								{
									case 4:
										p2b.field_size = (dst[BYTE] = (byte) (p2b.crc >>> 8)) == BR ? 3 : 2;
										continue;
									case 3:
										dst[BYTE] = BR;
										p2b.field_size = 2;
										continue;
									case 2:
										if ((dst[BYTE] = (byte) (p2b.crc & 0xFF)) != BR) break;
										p2b.field_size = 1;
										continue;
									case 1:
										dst[BYTE] = BR;
								}
								p2b.state = Flow.STATE.STANDBY;
								p2b.mode = Flow.MODE.NONE;
								p2b.pack = null;
								continue;
							}
							if ((p2b._fbbox = dst[BYTE] = p2b.pack.data[p2b._Wbbox++]) == BR)
							{
								p2b.state = Flow.STATE.BYTES_BR;
								continue;
							}
						case BYTES_BR:
							p2b.state = Flow.STATE.BYTES;
							dst[BYTE] = (byte) p2b._fbbox;
							if (p2b._Wbbox < p2b._ubbox) continue;
							break;
						case VARINT:
							if ((p2b._fbbox & ~0x7FL) != 0)
							{
								dst[BYTE] = (byte) (p2b._fbbox & 0x7F | 0x80);
								p2b._fbbox >>>= 7;
								continue;
							}
							if (p2b._fbbox == BR)
							{
								p2b.state = Flow.STATE.VARINT_BR;
								dst[BYTE] = BR;
								continue;
							}
						case VARINT_BR:
							p2b.state = Flow.STATE.VARINT;
							dst[BYTE] = (byte) p2b._fbbox;
							if ((p2b._Wbbox += p2b.field_size) < p2b._ubbox)
							{
								p2b._fbbox = get_bytes(p2b.pack.data, p2b._Wbbox, p2b.field_size);
								continue;
							}
					}
					if (p2b.next())
					{
						if (p2b.state == Flow.STATE.VARINT) p2b._fbbox = get_bytes(p2b.pack.data, p2b._Wbbox, p2b.field_size);
						continue;
					}
					p2b.state = Flow.STATE.BYTES;
					p2b.mode = Flow.MODE.CRC;
					p2b.field_size = 4;
				}
				return BYTE - fix;
			}
		}

		public class AdvancedOutputStream extends OutputStream {
			int bits = 0;

			@Override public void write(byte[] src, int BYTE, int bytes) throws IOException {
				time = ~0;
				if (time == 0)
				{
					time = ~0;
					b2p.state = Flow.STATE.STANDBY;
					if (b2p.pack != null) b2p.pack = null;
				}
				for (int t; 0 < bytes--; t = b2p.mode != Flow.MODE.CRC ? b2p.crc = crc16(src[BYTE], b2p.crc) : 0, BYTE++)
				{
					switch (b2p.state)
					{
						case STANDBY:
							b2p.crc = 0;
							b2p._fbbox = 0;
							bits = 0;
							if (src[BYTE] == BR) b2p.state = Flow.STATE.PACK_ID;
							continue;
						case PACK_ID:
							if (src[BYTE] == BR)
							{
								failure(" After BR expect helper ID but got +BR");
								b2p.state = Flow.STATE.STANDBY;
								continue;
							}
							b2p._fbbox = b2p._fbbox << 8 | src[BYTE] & 0xFF;
							if (++bits < pack_id_bytes) continue;
							b2p.mode = Flow.MODE.NONE;
							assert b2p.pack == null;
							if ((b2p.pack = process(null, (int) b2p._fbbox)) == null)
							{
								failure("Unrecognized package ID = " + b2p._fbbox);
								b2p.state = Flow.STATE.STANDBY;
								continue;
							}
							b2p._fbbox = 0;
							bits = 0;
							b2p.field_bit = -1;
							b2p._vbbox = b2p._Obbox = b2p._ubbox = b2p._Wbbox = b2p.field_size = 0;
							if (b2p.pack.meta.fields != null)
							{
								b2p.state = Flow.STATE.VARINT;
								b2p.mode = Flow.MODE.OPTS_INFO;
								continue;
							}
							break;
						case BYTES:
							if (src[BYTE] == BR)
							{
								b2p.state = Flow.STATE.BYTES_BR;
								continue;
							}
						case BYTES_BR:
							if (b2p.state == Flow.STATE.BYTES_BR)
							{
								if (src[BYTE] != BR)
								{
									failure("waiting for second BR but got " + src[BYTE]);
									b2p.state = Flow.STATE.STANDBY;
									continue;
								}
								b2p.state = Flow.STATE.BYTES;
							}
							if (b2p.mode == Flow.MODE.CRC)
								switch (b2p.field_size)
								{
									case 2:
										b2p._fbbox = (src[BYTE] & 0xFF) << 8;
										b2p.field_size = 1;
										continue;
									case 1:
										if ((b2p._fbbox | (src[BYTE] & 0xFF)) == b2p.crc) process(b2p.pack, PROCESS_CHANNEL_REQEST);
										else failure("CRC error");
										b2p.state = Flow.STATE.STANDBY;
										b2p.mode = Flow.MODE.NONE;
										b2p.pack = null;
										continue;
								}
							b2p.pack.data[b2p._Wbbox++] = src[BYTE];
							if (b2p._Wbbox < b2p._ubbox) continue;
							break;
						case VARINT:
							if (src[BYTE] == BR)
							{
								b2p.state = Flow.STATE.VARINT_BR;
								continue;
							}
						case VARINT_BR:
							if (b2p.state == Flow.STATE.VARINT_BR)
							{
								if (src[BYTE] != BR)
								{
									failure("waiting for second BR but got " + src[BYTE]);
									b2p.state = Flow.STATE.STANDBY;
									continue;
								}
								b2p.state = Flow.STATE.VARINT;
							}
							b2p._fbbox |= (src[BYTE] & 0x7FL) << bits;
							bits += 7;
							if ((src[BYTE] & 0x80) != 0) continue;
							bits = 0;
							if (b2p.mode == Flow.MODE.OPTS_INFO)
							{
								b2p.pack.data = new byte[b2p.pack.meta.packMinBytes + (int) b2p._fbbox];
								b2p._fbbox = 0;
								b2p.mode = Flow.MODE.NONE;
								break;
							}
							set_bytes(b2p._fbbox, b2p.field_size, b2p.pack.data, b2p._Wbbox);
							b2p._fbbox = 0;
							if ((b2p._Wbbox += b2p.field_size) < b2p._ubbox) continue;
							break;
					}
					if (b2p.next()) continue;
					b2p.state = Flow.STATE.BYTES;
					b2p.mode = Flow.MODE.CRC;
					b2p.field_size = 2;
				}
			}
		}


		public static class OnReceive<P extends Pack, C extends Channel> extends ArrayList<OnReceive.Handler<P, C>> {

			public void handle(C ch, Pack.Meta.Field.Bounds.Inside ph) {
				@SuppressWarnings("unchecked")
				P pack = (P) ph.pack;
				for (Handler<P, C> h : this) h.handle(ch, ph, pack);
			}

			public interface Handler<P extends Pack, C extends Channel> {
				void handle(C ch, Pack.Meta.Field.Bounds.Inside ph, P pack);
			}
		}

		volatile int time;

		protected void failure(String reason) { System.out.println("failure: " + reason); }

		protected abstract Pack process(Pack pack, int id);

		protected static final int PROCESS_CHANNEL_REQEST = -1, PROCESS_HOST_REQEST = -2, PROCESS_RECEIVED = -3;

		protected static void processReceived(Channel ch) {ch.process(null, PROCESS_RECEIVED);}
	}


	static void insert(Pack.Meta.Field.Bounds.Inside ph, final int fbit, final int bits, final int bytes) {
		if (ph.field_bit != fbit)
		{
			ph.BIT = ph._Obbox = ph._vbbox;
			ph.BYTE = ph._Wbbox = ph._ubbox;
		}
		final Pack.Meta meta = ph.pack.meta;
		if (ph._Hbbox < 0) _wbbox(ph);
		int add_to_bits_bytes;
		if (ph.BIT == ph._Dbbox && ph.BYTE == ph._Hbbox)
		{
			add_to_bits_bytes = meta._dbbox == 0 ? 0 : bits2bytes(fbit + bits - ph._Dbbox + 1);
			if (0 < add_to_bits_bytes || 0 < bytes)
			{
				final int old_pack_data_bytes = ph._Hbbox;
				assert (old_pack_data_bytes == ph.pack.data.length);
				final byte[] data = new byte[old_pack_data_bytes + add_to_bits_bytes + bytes];
				if (ph.field_bit == -1 || bits == 0)
					System.arraycopy(ph.pack.data, 0, data, 0, old_pack_data_bytes);
				else
				{
					copy_bits(ph.pack.data, 0,
							ph.field_bit + 1,
							data, 0);
					copy_bits(ph.pack.data, ph.BIT,
							(old_pack_data_bytes << 3) - ph.BIT, data, ph.BIT + (add_to_bits_bytes << 3));
				}
				ph._Hbbox += add_to_bits_bytes + bytes;
				ph.pack.data = data;
			}
		}
		else
		{
			final int add_bits_bits = meta._dbbox == 0 ? 0 : bits - (ph._Dbbox - (ph._nbbox + 1));
			add_to_bits_bytes = meta._dbbox == 0 ? 0 : bits2bytes(add_bits_bits);
			if (0 < add_to_bits_bytes || 0 < bytes)
			{
				final int old_pack_data_bytes = ph._Hbbox;
				assert (old_pack_data_bytes == ph.pack.data.length);
				final byte[] data = new byte[old_pack_data_bytes + add_to_bits_bytes + bytes];
				if (bits == 0)
					System.arraycopy(ph.pack.data, 0, data, 0, ph.BYTE + 1);
				else
				{
					copy_bits(ph.pack.data, 0,
							ph._nbbox + 1,
							data, 0);
					copy_bits(ph.pack.data, ph._Dbbox,
							ph.BIT - ph._Dbbox, data, ph._Dbbox + (add_to_bits_bytes << 3) - bits);
					copy_bits(ph.pack.data, ph.BIT, (ph.BYTE << 3) - ph.BIT, data, ph.BIT + (add_to_bits_bytes << 3));
				}
				System.arraycopy(
						ph.pack.data, ph.BYTE, data, ph.BYTE + add_to_bits_bytes + bytes, ph._Hbbox - ph.BYTE);
				ph._Hbbox += add_to_bits_bytes + bytes;
				ph.pack.data = data;
			}
			else
			{
				copy_bits(ph.pack.data, ph._Dbbox,
						ph.BIT - ph._Dbbox, ph.pack.data, ph._Dbbox - bits);
				set_0(ph.pack.data, ph.BIT - bits, bits);
			}
		}
		if (0 < meta._dbbox && 0 < add_to_bits_bytes)
		{
			int old_value = (int) get_bits(ph.pack.data, meta._Jbbox - meta._dbbox, meta._dbbox);
			set_bits(old_value + add_to_bits_bytes, meta._dbbox, ph.pack.data, meta._Jbbox - meta._dbbox);
		}
		final int zazor_delta = (add_to_bits_bytes << 3) - bits;
		ph._Dbbox += zazor_delta;
		ph.BIT += add_to_bits_bytes << 3;
		ph.BYTE += add_to_bits_bytes;
		if (fbit == ph.field_bit)
		{
			ph._vbbox += zazor_delta;
			ph._Obbox += add_to_bits_bytes << 3;
			ph._Wbbox += add_to_bits_bytes;
			ph._ubbox += add_to_bits_bytes + bytes;
		}
		else
		{
			ph._Obbox = ph._vbbox = ph.BIT;
			ph._ubbox = ph._Wbbox = ph.BYTE;
			ph.pack.data[fbit >> 3] |= 1 << (fbit & 7);
			if (ph._nbbox < fbit) ph._nbbox = fbit;
			ph.field_bit = fbit;
			ph.field = meta.fields[ph.field_bit - meta._Jbbox];
		}
	}

	static boolean visit_field(Pack.Meta.Field.Bounds.Inside ph, int fbit) {
		if (ph.field_bit == fbit) return true;
		final Pack.Meta meta = ph.pack.meta;
		final byte[]    data = ph.pack.data;
		int             delta;
		for (; ; )
			if (ph.field_bit == -1)
			{
				if ((delta = first_1(data, meta._Jbbox, ph._vbbox - meta._Jbbox, false)) == -1 ||
				    fbit < meta._Jbbox + delta) return false;
				ph.field_bit = meta._Jbbox - 1;
				break;
			}
			else
				if (fbit < ph.field_bit) ph.setPack(ph.pack);
				else
				{
					if (ph.field_bit - meta._Jbbox == meta.fields.length - 1 ||
					    (delta = first_1(data, ph.field_bit + 1, ph._vbbox - (ph.field_bit + 1), false)) == -1 ||
					    fbit < ph.field_bit + 1 + delta) return false;
					break;
				}
		for (; ; )
		{
			final Pack.Meta.Field fld = meta.fields[(ph.field_bit += 1 + delta) - meta._Jbbox];
			ph.field = fld;
			ph._Obbox = ph._vbbox;
			ph._Wbbox = ph._ubbox;
			if (0 < fld.length) if (0 < fld.size) ph._ubbox += fld._Ubbox * fld.length * fld.size;
			else ph._vbbox += fld._Ubbox * fld.length * fld.size;
			else setBounds(fld, ph);
			if (ph.field_bit == fbit || ph.field_bit - meta._Jbbox == meta.fields.length - 1 ||
			    (delta = first_1(data, ph.field_bit + 1, ph._vbbox - (ph.field_bit + 1), false)) == -1 ||
			    fbit < ph.field_bit + 1 + delta)
			{
				ph.items = fld.length;
				ph.field_size = fld.size;
				ph.BIT = ph._vbbox;
				ph.BYTE = ph._Wbbox;
				if (fld.length < 1)
				{
					ph._lbbox = fld._Ubbox;
					if (0 < fld._Sbbox)
					{
						if (ph.D == null || ph.D.length < fld.dims.length) ph.D = new int[fld.dims.length];
						else for (int i = ph.D.length - 1; -1 < i; ) ph.D[i--] = 0;
						for (int i = 0, bit = ph._Obbox, dim; i < fld.dims.length; i++)
							if ((dim = fld.dims[i]) < 1) ph._lbbox *= ph.D[i] = (int) get_bits(data, bit -= -dim, -dim);
							else ph.D[i] = dim;
					}
					init(fld, ph);
				}
				return ph.field_bit == fbit;
			}
		}
	}


	static void init(Pack.Meta.Field fld, Pack.Meta.Field.Bounds.Inside ph) {
		switch (fld.type)
		{
			case 1:
				ph.items = -fld.length;
				ph.BIT = ph._vbbox;
				ph.BYTE = ph._Wbbox;
				break;
			case 2:
			case 6:
			case 8:
			case 12:
				ph.items = -fld.length;
				ph.BYTE = ph._Wbbox;
				ph.BIT = ph._Obbox - fld._pbbox;
				ph.field_item = Integer.MAX_VALUE;
				ph._Ibbox = (int) get_bits(ph.pack.data, ph.BIT, fld._hbbox);
				ph._ibbox = (int) get_bits(ph.pack.data, ph.BIT + fld._hbbox, fld._hbbox);
				break;
			case 3:
				ph.BYTE = ph._Wbbox;
				ph.items = (int) get_bits(ph.pack.data, (ph.BIT = ph._Obbox - fld._pbbox), -fld.length);
				break;
			case 4:
				ph.items = (int) get_bits(ph.pack.data, (ph.BIT = ph._Obbox - fld._pbbox) + 2 * fld._hbbox, -fld.length);
				ph.BYTE = ph._Wbbox;
				ph.field_item = Integer.MAX_VALUE;
				ph._Ibbox = (int) get_bits(ph.pack.data, ph.BIT, fld._hbbox);
				ph._ibbox = (int) get_bits(ph.pack.data, ph.BIT + fld._hbbox, fld._hbbox);
				break;
			case 5:
			case 11:
				ph.items = 0;
				ph.BYTE = ph._Wbbox;
				ph.BIT = ph._Obbox - fld._pbbox;
				ph._ibbox = 0;
				ph.field_item = Integer.MAX_VALUE;
				ph._Ibbox = ph._lbbox;
				break;
			case 7:
				ph.items = -fld.length;
				ph.BYTE = ph._Wbbox;
				ph._ibbox = 0;
				ph.BIT = ph._vbbox;
				ph.field_item = (ph._Ibbox = ph._lbbox) == 0 ? Integer.MAX_VALUE : 0;
				break;
			case 9:
				ph.items = (int) get_bits(ph.pack.data, (ph.BIT = ph._Obbox - fld._pbbox), -fld.length);
				ph.BYTE = ph._Wbbox;
				ph._ibbox = 0;
				ph.BIT = ph._vbbox;
				ph.field_item = (ph._Ibbox = ph._lbbox) == 0 ? Integer.MAX_VALUE : 0;
				break;
			case 10:
				ph.items = (int) get_bits(ph.pack.data, (ph.BIT = ph._Obbox - fld._pbbox) + 2 * fld._hbbox, -fld.length);
				ph.BYTE = ph._Wbbox;
				ph.field_item = Integer.MAX_VALUE;
				ph._Ibbox = (int) get_bits(ph.pack.data, ph.BIT, fld._hbbox);
				ph._ibbox = (int) get_bits(ph.pack.data, ph.BIT + fld._hbbox, fld._hbbox);
				break;
			default:
				assert (false);
		}
	}

	static void setBounds(Pack.Meta.Field fld, Pack.Meta.Field.Bounds ph) {
		ph.field_size = fld.size;
		switch (fld.type)
		{
			case 1:
				int count = 1;
				if (0 < fld._Sbbox) for (int i = 0, bit = ph._vbbox; i < fld.dims.length; i++) if (fld.dims[i] < 0) count *= get_bits(ph.pack.data, bit -= -fld.dims[i], -fld.dims[i]);
				ph._vbbox -= fld._pbbox;
				ph._ubbox += fld._Ubbox * count * -fld.length * fld.size;
				break;
			case 2:
				count = (int) get_bits(ph.pack.data, ph._vbbox -= fld._pbbox, fld._hbbox);
				if (count == 0) return;
				ph.field_size = fld.size;
				int bit = ph._vbbox;
				ph._vbbox -= count;
				byte[] data = ph.pack.data;
				while (ph._vbbox < bit--) if ((data[bit >>> 3] & 1 << (bit & 7)) == 0) count--;
				ph._ubbox += -fld.length * count * fld.size;
				break;
			case 3:
				ph.field_size = fld.size;
				bit = ph._vbbox;
				ph._vbbox -= fld._pbbox;
				int arrays_length = (int) get_bits(ph.pack.data, ph._vbbox, -fld.length);
				if (0 < fld._Sbbox) for (int i = 0; i < fld.dims.length; i++) if (fld.dims[i] < 0) arrays_length *= get_bits(ph.pack.data, bit -= -fld.dims[i], -fld.dims[i]);
				ph._ubbox += fld._Ubbox * arrays_length * fld.size;
				break;
			case 4:
				count = (int) get_bits(ph.pack.data, ph._vbbox -= fld._pbbox, fld._hbbox);
				if (count == 0) return;
				ph.field_size = fld.size;
				bit = ph._vbbox;
				ph._vbbox -= count;
				data = ph.pack.data;
				arrays_length = (int) get_bits(data, bit + 2 * fld._hbbox, -fld.length);
				while (ph._vbbox < bit--) if ((data[bit >>> 3] & 1 << (bit & 7)) == 0) count--;
				ph._ubbox += count * arrays_length * fld.size;
				break;
			case 5:
				ph.field_size = fld.size;
				count = fld._Ubbox;
				if (0 < fld._Sbbox) for (int i = 0, _bit = ph._vbbox; i < fld.dims.length; i++) if (fld.dims[i] < 0) count *= get_bits(ph.pack.data, _bit -= -fld.dims[i], -fld.dims[i]);
				ph._vbbox -= fld._pbbox;
				int all_arrays_sum = 0;
				while (0 < count--) all_arrays_sum += get_bits(ph.pack.data, ph._vbbox -= -fld.length, -fld.length);
				ph._ubbox += all_arrays_sum * fld.size;
				break;
			case 6:
				count = (int) get_bits(ph.pack.data, ph._vbbox -= fld._pbbox, fld._hbbox);
				if (count == 0) return;
				ph.field_size = fld.size;
				bit = ph._vbbox;
				all_arrays_sum = 0;
				data = ph.pack.data;
				while (0 < count--) if ((data[--bit >> 3] & 1 << (bit & 7)) != 0) all_arrays_sum += get_bits(ph.pack.data, bit -= -fld.length, -fld.length);
				ph._vbbox = bit;
				ph._ubbox += all_arrays_sum * fld.size;
				break;
			case 7:
				ph.field_size = 0;
				count = 1;
				if (0 < fld._Sbbox) for (int i = 0, _bit = ph._vbbox; i < fld.dims.length; i++) if (fld.dims[i] < 0) count *= get_bits(ph.pack.data, _bit -= -fld.dims[i], -fld.dims[i]);
				ph._vbbox -= fld._pbbox + count * fld._Ubbox * -fld.length * fld.size;
				break;
			case 8:
				count = (int) get_bits(ph.pack.data, ph._vbbox -= fld._pbbox, fld._hbbox);
				if (count == 0) return;
				bit = ph._vbbox;
				ph.field_size = fld.size;
				data = ph.pack.data;
				for (final int bits = -fld.length * fld.size; 0 < count--; )
					if ((data[--bit >> 3] & 1 << (bit & 7)) != 0) bit -= bits;
				ph._vbbox = bit;
				break;
			case 9:
				ph.field_size = fld.size;
				bit = ph._vbbox;
				ph._vbbox -= fld._pbbox;
				arrays_length = (int) get_bits(ph.pack.data, ph._vbbox, -fld.length);
				if (0 < fld._Sbbox) for (int i = 0; i < fld.dims.length; i++) if (fld.dims[i] < 0) arrays_length *= get_bits(ph.pack.data, bit -= -fld.dims[i], -fld.dims[i]);
				ph._vbbox -= fld._Ubbox * arrays_length * fld.size;
				break;
			case 10:
				count = (int) get_bits(ph.pack.data, ph._vbbox -= fld._pbbox, fld._hbbox);
				if (count == 0) return;
				bit = ph._vbbox;
				ph.field_size = fld.size;
				data = ph.pack.data;
				for (final int bits = (int) get_bits(data, bit + 2 * fld._hbbox, -fld.length) * fld.size; 0 < count--; )
					if ((data[--bit >> 3] & 1 << (bit & 7)) != 0) bit -= bits;
				ph._vbbox = bit;
				break;
			case 11:
				ph.field_size = fld.size;
				count = fld._Ubbox;
				if (0 < fld._Sbbox) for (int i = 0, _bit = ph._vbbox; i < fld.dims.length; i++) if (fld.dims[i] < 0) count *= get_bits(ph.pack.data, _bit -= -fld.dims[i], -fld.dims[i]);
				ph._vbbox -= fld._pbbox;
				while (0 < count--)
				{
					int bits = (int) (get_bits(ph.pack.data, ph._vbbox -= -fld.length, -fld.length) * fld.size);
					ph._vbbox -= bits;
				}
				break;
			case 12:
				count = (int) get_bits(ph.pack.data, ph._vbbox -= fld._pbbox, fld._hbbox);
				if (count == 0) return;
				ph.field_size = fld.size;
				bit = ph._vbbox;
				all_arrays_sum = 0;
				data = ph.pack.data;
				while (0 < count--) if ((data[--bit >> 3] & 1 << (bit & 7)) != 0)
				{
					int len = (int) get_bits(ph.pack.data, bit -= -fld.length, -fld.length);
					bit -= len * fld.size;
				}
				ph._vbbox = bit;
				break;
			default:
				assert (false);
		}
	}


	static void _wbbox(Pack.Meta.Field.Bounds ph) {
		final Pack.Meta meta = ph.pack.meta;
		ph._nbbox = ph.field_bit == -1 ? meta._Jbbox - 1 : ph.field_bit;
		int delta = ph.field_bit == -1 ? first_1(ph.pack.data, meta._Jbbox, ph._vbbox - meta._Jbbox, false) : first_1(ph.pack.data, ph.field_bit + 1, ph._vbbox - (ph.field_bit + 1), false);
		if (delta == -1)
		{
			ph._Hbbox = ph._ubbox;
			ph._nbbox = ph.field_bit;
			ph._Dbbox = ph._vbbox;
			assert (ph._Hbbox == (ph.pack.data.length));
		}
		else
		{
			final int _vbbox_FX = ph._vbbox, _Obbox_FX = ph._Obbox, _Wbbox_FX = ph._Wbbox, _ubbox_FX = ph._ubbox, item_size_FX = ph.field_size;
			for (int max = meta._Jbbox + meta.fields.length - 1; ; )
			{
				ph._nbbox += delta + 1;
				ph._Obbox = ph._vbbox;
				ph._Wbbox = ph._ubbox;
				final Pack.Meta.Field fld = meta.fields[ph._nbbox - meta._Jbbox];
				if (0 < fld.length) if (0 < fld.size) ph._ubbox += fld._Ubbox * fld.length * fld.size;
				else ph._vbbox += fld._Ubbox * fld.length * fld.size;
				else setBounds(fld, ph);
				if (ph._nbbox == max || (delta = first_1(ph.pack.data, ph._nbbox + 1, ph._vbbox - (ph._nbbox + 1), false)) == -1) break;
			}
			ph._Hbbox = ph._ubbox;
			ph._Dbbox = ph._vbbox;
			assert (ph._Hbbox == ph.pack.data.length);
			ph._vbbox = _vbbox_FX;
			ph._Obbox = _Obbox_FX;
			ph._Wbbox = _Wbbox_FX;
			ph._ubbox = _ubbox_FX;
			ph.field_size = item_size_FX;
		}
	}

	public static boolean insert_field(Pack.Meta.Field.Bounds.Inside ph, int fbit, int items, int... var_dims) {
		if (visit_field(ph, fbit)) return false;
		Pack.Meta.Field fld = ph.pack.meta.fields[fbit - ph.pack.meta._Jbbox];
		if (fld.type == 0)
		{
			if (visit_field(ph, fbit)) return false;
			if (0 < fld.size)
			{
				insert(ph, fbit, 0, fld._Ubbox * fld.length * fld.size);
				ph._ubbox = (ph.BYTE = ph._Wbbox) + fld._Ubbox * (ph.items = fld.length) * (ph.field_size = fld.size);
			}
			else
			{
				insert(ph, fbit, fld._Ubbox * fld.length * -fld.size, 0);
				ph.BIT = ph._vbbox = ph._Obbox + fld._Ubbox * (ph.items = fld.length) * fld.size;
			}
			return true;
		}
		int total = fld._Ubbox;
		if (var_dims != null)
			for (int i = var_dims.length - 1; -1 < i; i--) total *= var_dims[i];
		switch (fld.type)
		{
			case 1:
				insert(ph, fbit, fld._pbbox, total * -fld.length * fld.size);
				break;
			case 2:
			case 6:
			case 8:
			case 12:
				insert(ph, fbit, fld._pbbox, 0);
				break;
			case 3:
				insert(ph, fbit, fld._pbbox, total * items * fld.size);
				set_bits(items, -fld.length, ph.pack.data, ph._Obbox - fld._pbbox);
				break;
			case 4:
				insert(ph, fbit, fld._pbbox, 0);
				set_bits(items, -fld.length, ph.pack.data, ph._Obbox - fld._pbbox + 2 * fld._hbbox);
				break;
			case 5:
			case 11:
				insert(ph, fbit, fld._pbbox + total * -fld.length, 0);
				break;
			case 7:
				insert(ph, fbit, fld._pbbox + total * -fld.length * fld.size, 0);
				break;
			case 9:
				insert(ph, fbit, fld._pbbox + total * items * fld.size, 0);
				set_bits(items, -fld.length, ph.pack.data, ph._Obbox - fld._pbbox);
				break;
			case 10:
				insert(ph, fbit, fld._pbbox, 0);
				set_bits(items, -fld.length, ph.pack.data, ph._Obbox - fld._pbbox + 2 * fld._hbbox);
				break;
			default:
				assert (false);
		}
		ph._lbbox = total;
		if (0 < fld._Sbbox)
		{
			if (ph.D == null || ph.D.length < fld.dims.length) ph.D = new int[fld.dims.length];
			else for (int i = ph.D.length - 1; -1 < i; ) ph.D[i--] = 0;
			for (int i = 0, k = 0, bit = ph._Obbox; i < fld.dims.length; i++)
				if (fld.dims[i] < 1)
				{
					ph.D[i] = var_dims[k];
					set_bits(var_dims[k], -fld.dims[i], ph.pack.data, bit -= -fld.dims[i]);
					k++;
				}
				else ph.D[i] = fld.dims[i];
		}
		setBounds(fld, ph);
		init(fld, ph);
		return true;
	}

	public static boolean try_visit_item(Pack.Meta.Field.Bounds.Inside ph, int item) {
		final Pack.Meta.Field fld = ph.field;
		switch (fld.type)
		{
			default:
				assert (false);
				return false;
			case 2:
			case 4:
				if (ph.field_item == item) return true;
				if (ph._Ibbox == 0 || item < ph._ibbox || ph._ibbox + ph._Ibbox <= item) return false;
				int bit = ph._Obbox - fld._pbbox - 1 - (item - ph._ibbox);
				if ((ph.pack.data[bit >> 3] & 1 << (bit & 7)) == 0) return false;
				if (item < ph.field_item)
				{
					ph.field_item = ph._ibbox;
					ph.BIT = ph._Obbox - fld._pbbox - 1;
					ph.BYTE = ph._Wbbox;
				}
				else
				{
					ph.BIT--;
					ph.field_item++;
					ph.BYTE += ph.items * fld.size;
				}
				for (final int bytes = ph.items * fld.size; ; ph.field_item++, ph.BIT--)
					if ((ph.pack.data[ph.BIT >> 3] & 1 << (ph.BIT & 7)) != 0) if (ph.field_item == item) break;
					else ph.BYTE += bytes;
				return true;
			case 5:
				if (ph._lbbox - 1 < item || get_bits(ph.pack.data, ph._Obbox - fld._pbbox - (item + 1) * -fld.length, -fld.length) == 0) return false;
				if (item < ph.field_item)
				{
					ph.field_item = 0;
					ph.BIT = ph._Obbox - fld._pbbox;
					ph.items = (int) get_bits(ph.pack.data, ph.BIT -= -fld.length, -fld.length);
					ph.BYTE = ph._Wbbox;
				}
				for (; ph.field_item < item; ph.BYTE += ph.items * fld.size, ph.items = (int) get_bits(ph.pack.data, ph.BIT -= -fld.length, -fld.length), ph.field_item++) ;
				return true;
			case 6:
				if (ph.field_item == item) return true;
				if (item < ph._ibbox || ph._ibbox + ph._Ibbox <= item) return false;
				int field_item = ph.field_item;
				bit = ph.BIT;
				int BYTE = ph.BYTE;
				if (item < field_item)
				{
					field_item = ph._ibbox;
					bit = ph._Obbox - fld._pbbox - 1;
					BYTE = ph._Wbbox;
				}
				else
				{
					bit--;
					field_item++;
					BYTE += ph.items * fld.size;
				}
				for (final int len_bits = -fld.length; ; bit--, field_item++)
					if ((ph.pack.data[bit >>> 3] & 1 << (bit & 7)) != 0)
					{
						bit -= len_bits;
						if (field_item == item)
						{
							ph.field_item = field_item;
							ph.BYTE = BYTE;
							ph.BIT = bit;
							ph.items = (int) get_bits(ph.pack.data, bit, len_bits);
							return true;
						}
						BYTE += get_bits(ph.pack.data, bit, len_bits) * fld.size;
					}
					else
						if (field_item == item) return false;
			case 8:
			case 10:
				if (ph.field_item == item) return true;
				if (item < ph._ibbox || ph._ibbox + ph._Ibbox <= item) return false;
				field_item = ph.field_item;
				bit = ph.BIT;
				if (item < field_item)
				{
					field_item = ph._ibbox;
					bit = ph._Obbox - fld._pbbox - 1;
				}
				else
				{
					bit--;
					field_item++;
				}
				for (int bits = ph.items * fld.size; ; bit--, field_item++)
					if ((ph.pack.data[bit >>> 3] & 1 << (bit & 7)) != 0)
					{
						bit -= bits;
						if (field_item == item)
						{
							ph.field_item = item;
							ph.BIT = bit;
							return true;
						}
					}
					else
						if (field_item == item) return false;
			case 11:
				if (ph._lbbox - 1 < item) return false;
				field_item = ph.field_item;
				bit = ph.BIT;
				if (item < field_item)
				{
					field_item = -1;
					bit = ph._Obbox - fld._pbbox;
				}
				else
					if (item == ph.field_item) return true;
				int items;
				do
				{
					int bits = fld.size * (items = (int) get_bits(ph.pack.data, bit -= -fld.length, -fld.length));
					bit -= bits;
					field_item++;
				}
				while (field_item < item);
				if (items == 0) return false;
				ph.BIT = bit;
				ph.items = items;
				ph.field_item = field_item;
				return true;
			case 12:
				if (ph.field_item == item) return true;
				if (item < ph._ibbox || ph._ibbox + ph._Ibbox <= item) return false;
				field_item = ph.field_item;
				bit = ph.BIT;
				if (item < field_item)
				{
					field_item = ph._ibbox;
					bit = ph._Obbox - fld._pbbox - 1;
				}
				else
				{
					bit--;
					field_item++;
				}
				for (final int len_bits = -fld.length; ; bit--, field_item++)
					if ((ph.pack.data[bit >>> 3] & 1 << (bit & 7)) != 0)
					{
						bit -= len_bits;
						if (field_item == item)
						{
							ph.field_item = field_item;
							ph.items = (int) get_bits(ph.pack.data, bit, len_bits);
							ph.BIT = bit - ph.items * fld.size;
							return true;
						}
						bit -= get_bits(ph.pack.data, bit, len_bits) * fld.size;
					}
					else
						if (field_item == item) return false;
		}
	}


	public static void insert_item(Pack.Meta.Field.Bounds.Inside ph, int item, int items) {
		final Pack.Meta.Field fld = ph.field;
		switch (fld.type)
		{
			default:
				assert (false);
				return;
			case 2:
			case 4:
				if (item < ph._ibbox || ph._Ibbox == 0)
				{
					ph.BIT = ph._Obbox - fld._pbbox;
					ph.BYTE = ph._Wbbox;
					final int ins_items = ph._Ibbox == 0 ? 1 : ph._ibbox - item;
					insert(ph, ph.field_bit, ins_items, ph.items * fld.size);
					ph.BIT = ph._Obbox - fld._pbbox - 1;
					set_bits(ph._ibbox = item, fld._hbbox, ph.pack.data, ph._Obbox - fld._pbbox + fld._hbbox);
					set_bits(ph._Ibbox += ins_items, fld._hbbox, ph.pack.data, ph._Obbox - fld._pbbox);
				}
				else
					if (item < ph._ibbox + ph._Ibbox)
					{
						if (item < ph.field_item)
						{
							ph.field_item = ph._ibbox;
							ph.BIT = ph._Obbox - fld._pbbox - 1;
							ph.BYTE = ph._Wbbox;
						}
						else
						{
							ph.BIT--;
							ph.field_item++;
							ph.BYTE += ph.items * fld.size;
						}
						for (final int bytes = ph.items * fld.size; ph.field_item < item; ph.field_item++, ph.BIT--)
							if ((ph.pack.data[ph.BIT >> 3] & 1 << (ph.BIT & 7)) != 0) ph.BYTE += bytes;
						assert ((ph.pack.data[ph.BIT >>> 3] & 1 << (ph.BIT & 7)) == 0);
						insert(ph, ph.field_bit, 0, ph.items * fld.size);
					}
					else
					{
						final int ins_items = item + 1 - (ph._ibbox + ph._Ibbox);
						ph.BIT = ph._vbbox;
						ph.BYTE = ph._ubbox;
						insert(ph, ph.field_bit, ins_items, ph.items * fld.size);
						ph.BIT = ph._vbbox;
						ph.BYTE = ph._ubbox - ph.items * fld.size;
						set_bits(ph._Ibbox += ins_items, fld._hbbox, ph.pack.data, ph._Obbox - fld._pbbox);
					}
				ph.pack.data[ph.BIT >> 3] |= 1 << (ph.BIT & 7);
				break;
			case 5:
				if (ph._lbbox - 1 < item) throw new RuntimeException("No room for item=" + item + ". The _lbbox =" + ph._lbbox);
				if (item < ph.field_item)
				{
					ph.field_item = 0;
					ph.BIT = ph._Obbox - fld._pbbox;
					ph.BYTE = ph._Wbbox;
					ph.items = (int) get_bits(ph.pack.data, ph.BIT -= -fld.length, -fld.length);
				}
				for (; ph.field_item < item; ph.BYTE += ph.items * fld.size, ph.items = (int) get_bits(ph.pack.data, ph.BIT -= -fld.length, -fld.length), ph.field_item++) ;
				if (ph.items != 0) throw new RuntimeException("Already allocated");
				insert(ph, ph.field_bit, 0, items * fld.size);
				set_bits(items, -fld.length, ph.pack.data, ph.BIT);
				ph.items = items;
				break;
			case 6:
				int len_bits = -fld.length;
				if (item < ph._ibbox || ph._Ibbox == 0)
				{
					ph.BIT = ph._Obbox - fld._pbbox;
					ph.BYTE = ph._Wbbox;
					final int ins_items = ph._Ibbox == 0 ? 1 : ph._ibbox - item;
					insert(ph, ph.field_bit, ins_items + len_bits, items * fld.size);
					ph.BIT = ph._Obbox - fld._pbbox - 1;
					set_bits(ph._ibbox = item, fld._hbbox, ph.pack.data, ph._Obbox - fld._pbbox + fld._hbbox);
					set_bits(ph._Ibbox += ins_items, fld._hbbox, ph.pack.data, ph._Obbox - fld._pbbox);
				}
				else
					if (item < ph._ibbox + ph._Ibbox)
					{
						if (item < ph.field_item)
						{
							ph.field_item = ph._ibbox;
							ph.BIT = ph._Obbox - fld._pbbox - 1;
							ph.BYTE = ph._Wbbox;
						}
						else
						{
							ph.BIT--;
							ph.field_item++;
							ph.BYTE += ph.items * fld.size;
						}
						for (; ph.field_item < item; ph.BIT--, ph.field_item++)
							if ((ph.pack.data[ph.BIT >>> 3] & 1 << (ph.BIT & 7)) != 0)
							{
								ph.BIT -= len_bits;
								ph.items = (int) get_bits(ph.pack.data, ph.BIT, len_bits);
								ph.BYTE += ph.items * fld.size;
							}
						assert ((ph.pack.data[ph.BIT >>> 3] & 1 << (ph.BIT & 7)) == 0);
						insert(ph, ph.field_bit, len_bits, items * fld.size);
					}
					else
					{
						final int ins_items = item - (ph._ibbox + ph._Ibbox) + 1;
						ph.BIT = ph._vbbox;
						ph.BYTE = ph._ubbox;
						insert(ph, ph.field_bit, ins_items + len_bits, items * fld.size);
						ph.BIT = ph._vbbox + len_bits;
						ph.BYTE = ph._ubbox - items * fld.size;
						set_bits(ph._Ibbox += ins_items, fld._hbbox, ph.pack.data, ph._Obbox - fld._pbbox);
					}
				ph.pack.data[ph.BIT >>> 3] |= 1 << (ph.BIT & 7);
				set_bits(ph.items = items, len_bits, ph.pack.data, ph.BIT -= len_bits);
				break;
			case 8:
			case 10:
				int bits = ph.items * fld.size;
				if (ph.field_item == item) throw new RuntimeException();
				if (item < ph._ibbox || ph._Ibbox == 0)
				{
					ph.BIT = ph._Obbox - fld._pbbox;
					ph.BYTE = ph._Wbbox;
					int ins_items = ph._Ibbox == 0 ? 1 : ph._ibbox - item;
					insert(ph, ph.field_bit, ins_items + bits, 0);
					ph.BIT = ph._Obbox - fld._pbbox - 1;
					set_bits(ph._ibbox = item, fld._hbbox, ph.pack.data, ph._Obbox - fld._pbbox + fld._hbbox);
					set_bits(ph._Ibbox += ins_items, fld._hbbox, ph.pack.data, ph._Obbox - fld._pbbox);
				}
				else
					if (item < ph._ibbox + ph._Ibbox)
					{
						if (item < ph.field_item)
						{
							ph.field_item = ph._ibbox;
							ph.BIT = ph._Obbox - fld._pbbox - 1;
						}
						else
						{
							ph.BIT--;
							ph.field_item++;
						}
						for (; ph.field_item < item; ph.BIT--, ph.field_item++)
							if ((ph.pack.data[ph.BIT >>> 3] & 1 << (ph.BIT & 7)) != 0) ph.BIT -= bits;
						assert ((ph.pack.data[ph.BIT >>> 3] & 1 << (ph.BIT & 7)) == 0);
						insert(ph, ph.field_bit, bits, 0);
					}
					else
					{
						final int ins_items = item + 1 - (ph._ibbox + ph._Ibbox);
						ph.BIT = ph._vbbox;
						insert(ph, ph.field_bit, ins_items + bits, 0);
						ph.BIT = ph._vbbox + bits;
						set_bits(ph._Ibbox += ins_items, fld._hbbox, ph.pack.data, ph._Obbox - fld._pbbox);
					}
				ph.pack.data[ph.BIT >>> 3] |= 1 << (ph.BIT & 7);
				ph.BIT -= bits;
				break;
			case 11:
				if (ph._lbbox - 1 < item) throw new RuntimeException("No room for item=" + item + ". The _lbbox =" + ph._lbbox);
				if (item < ph.field_item)
				{
					ph.field_item = -1;
					ph.BIT = ph._Obbox - fld._pbbox;
				}
				if (ph.field_item < item) do
				{
					bits = (int) (fld.size * get_bits(ph.pack.data, ph.BIT -= -fld.length, -fld.length));
					ph.BIT -= bits;
					ph.field_item++;
				}
				while (ph.field_item < item);
				if (get_bits(ph.pack.data, ph.BIT, -fld.length) != 0) throw new RuntimeException("Already allocated");
				insert(ph, ph.field_bit, items * fld.size, 0);
				set_bits(items, -fld.length, ph.pack.data, ph.BIT);
				ph.BIT -= items * fld.size;
				ph.items = items;
				break;
			case 12:
				len_bits = -fld.length;
				if (item < ph._ibbox || ph._Ibbox == 0)
				{
					ph.BIT = ph._Obbox - fld._pbbox;
					final int ins_items = ph._Ibbox == 0 ? 1 : ph._ibbox - item;
					insert(ph, ph.field_bit, ins_items + len_bits + items * fld.size, 0);
					ph.BIT = ph._Obbox - fld._pbbox - 1;
					set_bits(ph._ibbox = item, fld._hbbox, ph.pack.data, ph._Obbox - fld._pbbox + fld._hbbox);
					set_bits(ph._Ibbox += ins_items, fld._hbbox, ph.pack.data, ph._Obbox - fld._pbbox);
				}
				else
					if (item < ph._ibbox + ph._Ibbox)
					{
						if (item < ph.field_item)
						{
							ph.field_item = ph._ibbox;
							ph.BIT = ph._Obbox - fld._pbbox - 1;
						}
						else
						{
							ph.BIT--;
							ph.field_item++;
						}
						for (; ph.field_item < item; ph.BIT--, ph.field_item++)
							if ((ph.pack.data[ph.BIT >>> 3] & 1 << (ph.BIT & 7)) != 0)
							{
								ph.BIT -= len_bits;
								ph.items = (int) get_bits(ph.pack.data, ph.BIT, len_bits);
								ph.BIT -= ph.items * fld.size;
							}
						assert ((ph.pack.data[ph.BIT >>> 3] & 1 << (ph.BIT & 7)) == 0);
						insert(ph, ph.field_bit, len_bits + items * fld.size, 0);
					}
					else
					{
						final int ins_items = item - (ph._ibbox + ph._Ibbox) + 1;
						ph.BIT = ph._vbbox;
						insert(ph, ph.field_bit, ins_items + len_bits + items * fld.size, 0);
						ph.BIT = ph._vbbox + items * fld.size + len_bits;
						set_bits(ph._Ibbox += ins_items, fld._hbbox, ph.pack.data, ph._Obbox - fld._pbbox);
					}
				ph.pack.data[ph.BIT >>> 3] |= 1 << (ph.BIT & 7);
				set_bits(ph.items = items, len_bits, ph.pack.data, ph.BIT -= len_bits);
				ph.BIT -= items * fld.size;
				break;
		}
		ph.field_item = item;
	}


	public static boolean try_visit_field(Pack.Meta.Field.Bounds.Inside ph, int fbit) {
		return !(ph.wasNULL = (ph._vbbox <= fbit || (ph.pack.data[fbit >> 3] & 1 << (fbit & 7)) == 0 || !visit_field(ph, fbit)));
	}


}